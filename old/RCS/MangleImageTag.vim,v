head	1.14;
access;
symbols;
locks; strict;
comment	@# @;


1.14
date	2020.09.12.03.01.19;	author Heptite;	state Exp;
branches;
next	1.13;

1.13
date	2009.06.23.14.04.35;	author infynity;	state Exp;
branches;
next	1.12;

1.12
date	2008.05.30.00.53.28;	author infynity;	state Exp;
branches;
next	1.11;

1.11
date	2008.05.26.01.11.25;	author infynity;	state Exp;
branches;
next	1.10;

1.10
date	2008.05.01.05.01.02;	author infynity;	state Exp;
branches;
next	1.9;

1.9
date	2007.05.04.02.03.42;	author infynity;	state Exp;
branches;
next	1.8;

1.8
date	2007.05.04.01.32.27;	author infynity;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.04.04.29.55;	author infynity;	state Exp;
branches;
next	1.6;

1.6
date	2006.09.22.06.25.14;	author infynity;	state Exp;
branches;
next	1.5;

1.5
date	2006.06.09.07.56.08;	author infynity;	state Exp;
branches;
next	1.4;

1.4
date	2006.06.08.04.16.17;	author infynity;	state Exp;
branches;
next	1.3;

1.3
date	2005.05.19.18.31.31;	author infynity;	state Exp;
branches;
next	1.2;

1.2
date	2004.03.22.10.04.24;	author infynity;	state Exp;
branches;
next	1.1;

1.1
date	2004.03.22.05.58.34;	author infynity;	state Exp;
branches;
next	;


desc
@Update an <IMG>'s width and height tags.
@


1.14
log
@Start trasition to Vim 8
@
text
@" MangleImageTag() - updates an <IMG>'s width and height tags.
"
" Requirements:
"       VIM 8 or later
"
" Copyright (C) 2004-2020 Christian J. Robinson <heptite@@gmail.com>
"
" Based on "mangleImageTag" by Devin Weaver <ktohg@@tritarget.com>
"
" This program is free software; you can  redistribute  it  and/or  modify  it
" under the terms of the GNU General Public License as published by  the  Free
" Software Foundation; either version 2 of the License, or  (at  your  option)
" any later version.
"
" This program is distributed in the hope that it will be useful, but  WITHOUT
" ANY WARRANTY; without  even  the  implied  warranty  of  MERCHANTABILITY  or
" FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General  Public  License  for
" more details.
"
" You should have received a copy of the GNU General Public License along with
" this program; if not, write to the Free Software Foundation, Inc., 59 Temple
" Place - Suite 330, Boston, MA 02111-1307, USA.
"
" RCS info: -------------------------------------------------------------- {{{
" $Id: MangleImageTag.vim,v 1.13 2009/06/23 14:04:35 infynity Exp $
" $Log: MangleImageTag.vim,v $
" Revision 1.13  2009/06/23 14:04:35  infynity
" Update email address
"
" Revision 1.12  2008/05/30 00:53:28  infynity
" - Clarify an error message
" - Don't move the cursor when updating the tag
"
" Revision 1.11  2008/05/26 01:11:25  infynity
" *** empty log message ***
"
" Revision 1.10  2008/05/01 05:01:02  infynity
" Code changed for Vim 7:
"  - Computed sizes should always be correct now
"  - Code is a bit cleaner, but unfortunately slower
"
" Revision 1.9  2007/05/04 02:03:42  infynity
" Computed sizes were very wrong when 'encoding' was set to UTF8 or similar
"
" Revision 1.8  2007/05/04 01:32:27  infynity
" Missing quotes
"
" Revision 1.7  2007/01/04 04:29:55  infynity
" Enclose the values of the width/height in quotes by default
"
" Revision 1.6  2006/09/22 06:25:14  infynity
" Search for the image file in the current directory and the buffer's directory.
"
" Revision 1.5  2006/06/09 07:56:08  infynity
" Was resetting 'autoindent' globally, switch it to locally.
"
" Revision 1.4  2006/06/08 04:16:17  infynity
" Temporarily reset 'autoindent' (required for Vim7)
"
" Revision 1.3  2005/05/19 18:31:31  infynity
" SizeGif was returning width as height and vice-versa.
"
" Revision 1.2  2004/03/22 10:04:24  infynity
" Update the right tag if more than one IMG tag appears on the line.
"
" Revision 1.1  2004/03/22 05:58:34  infynity
" Initial revision
" ------------------------------------------------------------------------ }}}

if v:version < 800 || exists("*MangleImageTag")
	finish
endif

function! MangleImageTag() "{{{1
	let l:start_linenr = line('.')
	let l:end_linenr = l:start_linenr
	let l:col = col('.') - 1
	let l:line = getline(l:start_linenr)

	if l:line !~? '<img'
		echohl ErrorMsg
		echomsg "The current line does not contain an image tag (see :help ;mi)."
		echohl None

		return
	endif

	" Get the rest of the tag if we have a partial tag:
	while l:line =~? '<img\_[^>]*$'
		let l:end_linenr = l:end_linenr + 1
		let l:line = l:line . "\n" . getline(l:end_linenr)
	endwhile

	" Make sure we modify the right tag if more than one is on the line:
	if l:line[col] != '<'
		let l:tmp = l:line->strpart(0, l:col)
		let l:tagstart = l:tmp->strridx('<')
	else
		let l:tagstart = l:col
	endif
	let l:savestart = l:line->strpart(0, l:tagstart)
	let l:tag = l:line->strpart(l:tagstart)
	let l:tagend = l:tag->stridx('>') + 1
	let l:saveend = l:tag->strpart(l:tagend)
	let l:tag = l:tag->strpart(0, l:tagend)

	if l:tag[0] != '<' || l:col > strlen(l:savestart . l:tag) - 1
		echohl ErrorMsg
		echomsg "Cursor isn't on an IMG tag."
		echohl None

		return
	endif

	if l:tag =~? "src=\\(\".\\{-}\"\\|'.\\{-}\'\\)"
		let l:src = l:tag->substitute(".\\{-}src=\\([\"']\\)\\(.\\{-}\\)\\1.*", '\2', '')
		if l:tag =~# 'src'
			let l:case = 0
		else
			let l:case = 1
		endif
	else
		echohl ErrorMsg
		echomsg "Image src not specified in the tag."
		echohl None

		return
	endif

	if ! filereadable(l:src)
		if filereadable(expand("%:p:h") . '/' . l:src)
			let l:src = expand("%:p:h") . '/' . l:src
		else
			echohl ErrorMsg
			echomsg "Can't find image file: " . l:src
			echohl None

			return
		endif
	endif

	let l:size = s:ImageSize(l:src)
	if len(l:size) != 2
		return
	endif

	if tag =~? "height=\\(\"\\d\\+\"\\|'\\d\\+\'\\|\\d\\+\\)"
		let l:tag = l:tag->substitute(
			\ "\\c\\(height=\\)\\([\"']\\=\\)\\(\\d\\+\\)\\(\\2\\)",
			\ '\1\2' . l:size[1] . '\4', '')
	else
		let l:tag = l:tag->substitute(
			\ "\\csrc=\\([\"']\\)\\(.\\{-}\\|.\\{-}\\)\\1",
			\ '\0 ' . (l:case ? 'HEIGHT' : 'height') . '="' . l:size[1] . '"', '')
	endif

	if l:tag =~? "width=\\(\"\\d\\+\"\\|'\\d\\+\'\\|\\d\\+\\)"
		let l:tag = l:tag->substitute(
			\ "\\c\\(width=\\)\\([\"']\\=\\)\\(\\d\\+\\)\\(\\2\\)",
			\ '\1\2' . l:size[0] . '\4', '')
	else
		let l:tag = l:tag->substitute(
			\ "\\csrc=\\([\"']\\)\\(.\\{-}\\|.\\{-}\\)\\1",
			\ '\0 ' . (l:case ? 'WIDTH' : 'width') . '="' . l:size[0] . '"', '')
	endif

	let l:line = l:savestart . l:tag . l:saveend

	let saveautoindent=&autoindent
	let &l:autoindent=0

	call setline(l:start_linenr, split(l:line, "\n"))

	let &l:autoindent=saveautoindent
endfunction

function! s:ImageSize(image) "{{{1
	let l:ext = fnamemodify(a:image, ':e')

	if l:ext !~? 'png\|gif\|jpe\?g'
		echohl ErrorMsg
		echomsg "Image type not recognized: " . tolower(l:ext)
		echohl None

		return
	endif

	if filereadable(a:image)
		let l:ldsave=&lazyredraw
		set lazyredraw

		let l:buf=readfile(a:image, 'b', 1024)
		let l:buf2=[]

		let l:i=0
		for l:l in l:buf
			let l:string = split(l:l, '\zs')
			for l:c in l:string
				let l:char = char2nr(l:c)
				call l:buf2->add((l:char == 10 ? '0' : l:char))

				" Keep the script from being too slow, but could cause a JPG
				" (and GIF/PNG?) to return as "malformed":
				let l:i+=1
				if l:i > 1024 * 4
					break
				endif
			endfor
			call l:buf2->add('10')
		endfor

		if l:ext ==? 'png'
			let l:size = l:buf2->s:SizePng()
		elseif l:ext ==? 'gif'
			let l:size = l:buf2->s:SizeGif()
		elseif l:ext ==? 'jpg' || ext ==? 'jpeg'
			let l:size = l:buf2->s:SizeJpg()
		endif
	else
		echohl ErrorMsg
		echomsg "Can't read file: " . a:image
		echohl None

		return
	endif

	return l:size
endfunction

function! s:SizeGif(lines) "{{{1
	let l:i = 0
	let l:len = len(a:lines)

	while l:i <= l:len
		if join(a:lines[l:i : l:i+9], ' ') =~ '^71 73 70\( \d\+\)\{7}'
			let l:width = a:lines[l:i+6 : l:i+7]->reverse()->s:Vec()
			let l:height = a:lines[l:i+8 : l:i+9]->reverse()->s:Vec()

			return [l:width, l:height]
		endif

		let l:i += 1
	endwhile

	echohl ErrorMsg
	echomsg "Malformed GIF file."
	echohl None

	return
endfunction

function! s:SizeJpg(lines) "{{{1
	let l:i=0
	let l:len=len(a:lines)

	while l:i <= len
		if join(a:lines[l:i : l:i+8], ' ') =~ '^255 192\( \d\+\)\{7}'
			let l:height = s:Vec(a:lines[l:i+5 : l:i+6])
			let l:width = s:Vec(a:lines[l:i+7 : l:i+8])

			return [l:width, l:height]
		endif
		let l:i += 1
	endwhile

	echohl ErrorMsg
	echomsg "Malformed JPEG file."
	echohl None

	return
endfunction

function! s:SizePng(lines) "{{{1
	let l:i=0
	let l:len=len(a:lines)

	while l:i <= len
		if join(a:lines[l:i : l:i+11], ' ') =~ '^73 72 68 82\( \d\+\)\{8}'
			let l:width = s:Vec(a:lines[l:i+4 : l:i+7])
			let l:height = s:Vec(a:lines[l:i+8 : l:i+11])

			return [l:width, l:height]
		endif
		let l:i += 1
	endwhile

	echohl ErrorMsg
	echomsg "Malformed PNG file."
	echohl None

	return
endfunction

function! s:Vec(nums) "{{{1
	let l:n = 0
	for l:i in a:nums
		let l:n = l:n * 256 + l:i
	endfor
	return l:n
endfunction

" vim:ts=4:sw=4:
" vim600:fdm=marker:fdc=2:cms=\ \"%s:
@


1.13
log
@Update email address
@
text
@d4 1
a4 1
"       VIM 7 or later
d6 1
a6 1
" Copyright (C) 2004-2008 Christian J. Robinson <heptite@@gmail.com>
d25 1
a25 1
" $Id: MangleImageTag.vim,v 1.12 2008/05/30 00:53:28 infynity Exp infynity $
d27 3
d70 1
a70 1
if v:version < 700 || exists("*MangleImageTag")
d75 4
a78 4
	let start_linenr = line('.')
	let end_linenr = start_linenr
	let col = col('.') - 1
	let line = getline(start_linenr)
d80 1
a80 1
	if line !~? '<img'
d89 3
a91 3
	while line =~? '<img\_[^>]*$'
		let end_linenr = end_linenr + 1
		let line = line . "\n" . getline(end_linenr)
d95 3
a97 3
	if line[col] != '<'
		let tmp = strpart(line, 0, col)
		let tagstart = strridx(tmp, '<')
d99 1
a99 1
		let tagstart = col
d101 5
a105 5
	let savestart = strpart(line, 0, tagstart)
	let tag = strpart(line, tagstart)
	let tagend = stridx(tag, '>') + 1
	let saveend = strpart(tag, tagend)
	let tag = strpart(tag, 0, tagend)
d107 1
a107 1
	if tag[0] != '<' || col > strlen(savestart . tag) - 1
d115 4
a118 4
	if tag =~? "src=\\(\".\\{-}\"\\|'.\\{-}\'\\)"
		let src = substitute(tag, ".\\{-}src=\\([\"']\\)\\(.\\{-}\\)\\1.*", '\2', '')
		if tag =~# 'src'
			let case = 0
d120 1
a120 1
			let case = 1
d130 3
a132 3
	if ! filereadable(src)
		if filereadable(expand("%:p:h") . '/' . src)
			let src = expand("%:p:h") . '/' . src
d135 1
a135 1
			echomsg "Can't find image file: " . src
d142 2
a143 2
	let size = s:ImageSize(src)
	if len(size) != 2
d148 1
a148 1
		let tag = substitute(tag,
d150 1
a150 1
			\ '\1\2' . size[1] . '\4', '')
d152 1
a152 1
		let tag = substitute(tag,
d154 1
a154 1
			\ '\0 ' . (case ? 'HEIGHT' : 'height') . '="' . size[1] . '"', '')
d157 2
a158 2
	if tag =~? "width=\\(\"\\d\\+\"\\|'\\d\\+\'\\|\\d\\+\\)"
		let tag = substitute(tag,
d160 1
a160 1
			\ '\1\2' . size[0] . '\4', '')
d162 1
a162 1
		let tag = substitute(tag,
d164 1
a164 1
			\ '\0 ' . (case ? 'WIDTH' : 'width') . '="' . size[0] . '"', '')
d167 1
a167 1
	let line = savestart . tag . saveend
d172 1
a172 1
	call setline(start_linenr, split(line, "\n"))
d178 1
a178 1
	let ext = fnamemodify(a:image, ':e')
d180 1
a180 1
	if ext !~? 'png\|gif\|jpe\?g'
d182 1
a182 1
		echomsg "Image type not recognized: " . tolower(ext)
d189 1
a189 1
		let ldsave=&lazyredraw
d192 2
a193 2
		let buf=readfile(a:image, 'b', 1024)
		let buf2=[]
d195 6
a200 6
		let i=0
		for l in buf
			let string = split(l, '\zs')
			for c in string
				let char = char2nr(c)
				call add(buf2, (char == 10 ? '0' : char))
d204 2
a205 2
				let i+=1
				if i > 1024 * 4
d209 1
a209 1
			call add(buf2, '10')
d212 6
a217 6
		if ext ==? 'png'
			let size = s:SizePng(buf2)
		elseif ext ==? 'gif'
			let size = s:SizeGif(buf2)
		elseif ext ==? 'jpg' || ext ==? 'jpeg'
			let size = s:SizeJpg(buf2)
d227 1
a227 1
	return size
d231 7
a237 6
	let i=0
	let len=len(a:lines)
	while i <= len
		if join(a:lines[i : i+9], ' ') =~ '^71 73 70\( \d\+\)\{7}'
			let width=s:Vec(reverse(a:lines[i+6 : i+7]))
			let height=s:Vec(reverse(a:lines[i+8 : i+9]))
d239 1
a239 1
			return [width, height]
d241 2
a242 1
		let i+=1
d253 2
a254 6
	let i=0
	let len=len(a:lines)
	while i <= len
		if join(a:lines[i : i+8], ' ') =~ '^255 192\( \d\+\)\{7}'
			let height = s:Vec(a:lines[i+5 : i+6])
			let width = s:Vec(a:lines[i+7 : i+8])
d256 6
a261 1
			return [width, height]
d263 1
a263 1
		let i+=1
d274 7
a280 6
	let i=0
	let len=len(a:lines)
	while i <= len
		if join(a:lines[i : i+11], ' ') =~ '^73 72 68 82\( \d\+\)\{8}'
			let width = s:Vec(a:lines[i+4 : i+7])
			let height = s:Vec(a:lines[i+8 : i+11])
d282 1
a282 1
			return [width, height]
d284 1
a284 1
		let i+=1
d295 3
a297 3
	let n = 0
	for i in a:nums
		let n = n * 256 + i
d299 1
a299 1
	return n
@


1.12
log
@- Clarify an error message
- Don't move the cursor when updating the tag
@
text
@d6 1
a6 1
" Copyright (C) 2004-2008 Christian J. Robinson <infynity@@onewest.net>
d25 1
a25 1
" $Id: MangleImageTag.vim,v 1.11 2008/05/26 01:11:25 infynity Exp infynity $
d27 4
@


1.11
log
@*** empty log message ***
@
text
@d25 1
a25 1
" $Id: MangleImageTag.vim,v 1.10 2008/05/01 05:01:02 infynity Exp infynity $
d27 3
d75 1
a75 1
		echomsg "Line doesn't contain an image tag."
d82 4
a85 6
	if line =~? '<img[^>]*$'
		while line =~? '<img\_[^>]*$'
			let end_linenr = end_linenr + 1
			let line = line . "\n" . getline(end_linenr)
		endwhile
	endif
d165 1
a165 1
	silent exe 'normal :' . start_linenr . ',' . end_linenr . "change\n" . line . "\n."
@


1.10
log
@Code changed for Vim 7:
 - Computed sizes should always be correct now
 - Code is a bit cleaner, but unfortunately slower
@
text
@d24 2
a25 2
" RCS info: ---------------------------------------------------------------{{{
" $Id: MangleImageTag.vim,v 1.9 2007/05/04 02:03:42 infynity Exp infynity $
d27 5
d58 1
a58 1
" -------------------------------------------------------------------------}}}
@


1.9
log
@Computed sizes were very wrong when 'encoding' was set to UTF8 or similar
@
text
@d4 1
a4 1
"       VIM 6 or later
d6 1
a6 1
" Copyright (C) March 2004  Christian J. Robinson <infynity@@onewest.net>
d25 1
a25 1
" $Id: MangleImageTag.vim,v 1.8 2007/05/04 01:32:27 infynity Exp infynity $
d27 3
d55 1
a55 1
if exists("*MangleImageTag")
d130 1
a130 1
	if size == ''
a132 2
	let width = strpart(size, 0, stridx(size, ' '))
	let height = strpart(size, stridx(size, ' ') + 1)
d137 1
a137 1
			\ '\1\2' . height . '\4', '')
d141 1
a141 1
			\ '\0 ' . (case ? 'HEIGHT' : 'height') . '="' . height . '"', '')
d147 1
a147 1
			\ '\1\2' . width . '\4', '')
d151 1
a151 1
			\ '\0 ' . (case ? 'WIDTH' : 'width') . '="' . width . '"', '')
d167 1
a167 1
	if ext !~? 'png\|gif\|jpg'
d171 2
a172 1
		return ''
a176 1
		let encsave=&encoding
a177 1
		set encoding=Latin1
d179 2
a180 3
		new ++enc=Latin1
		silent exe '$read ' . a:image
		go
d182 16
a197 1
		setlocal buftype=nofile noswapfile
d200 1
a200 1
			let size = s:SizePng()
d202 3
a204 3
			let size = s:SizeGif()
		elseif ext ==? 'jpg'
			let size = s:SizeJpg()
a205 5

		bwipe!

		let &lazyredraw=ldsave
		let &encoding=encsave
d211 1
a211 1
		return ''
d217 7
a223 8
function! s:SizeGif() "{{{1
	"if search("^GIF.......") == 0
	if search('^\CGIF\_.\_.\_.\_.\_.\_.\_.') == 0
		echohl ErrorMsg
		echomsg "Malformed GIF file."
		echohl None
		return ''
	endif
d225 4
a228 10
	let saveww=&ww
	set ww+=l

	let savea=@@a
	let saveb=@@b
	normal 6l"ay2l2l"by2l
	let width=@@a[1] . @@a[0]
	let height=@@b[1] . @@b[0]
	let @@a=savea
	let @@b=saveb
d230 3
a232 1
	let &ww=saveww
d234 1
a234 4
	let width = s:Vec(width)
	let height = s:Vec(height)

	return width . ' ' . height
d237 7
a243 8
function! s:SizeJpg() "{{{1
	"if search("\xff\xc0.......") == 0
	if search("\xff\xc0\\_.\\_.\\_.\\_.\\_.\\_.\\_.") == 0
		echohl ErrorMsg
		echomsg "Malformed JPEG file."
		echohl None
		return ''
	endif
d245 4
a248 10
	let saveww=&ww
	set ww+=l

	let savea=@@a
	let saveb=@@b
	normal 5l"ay2l2l"by2l
	let height=@@a
	let width=@@b
	let @@a=savea
	let @@b=saveb
d250 3
a252 1
	let &ww=saveww
d254 1
a254 4
	let width = s:Vec(width)
	let height = s:Vec(height)

	return width . ' ' . height
d257 7
a263 11
function! s:SizePng() "{{{1
	"if search('\CIHDR........') == 0
	if search('\CIHDR\_.\_.\_.\_.\_.\_.\_.\_.') == 0
		echohl ErrorMsg
		echomsg "Malformed PNG file."
		echohl None
		return ''
	endif

	let saveww=&ww
	set ww+=l
d265 4
a268 7
	let savea=@@a
	let saveb=@@b
	normal 4l"ay4l4l"by4l
	let width=@@a
	let height=@@b
	let @@a=savea
	let @@b=saveb
d270 3
a272 1
	let &ww=saveww
d274 1
a274 4
	let width = s:Vec(width)
	let height = s:Vec(height)

	return width . ' ' . height
d277 5
a281 13
function! s:Vec(str) "{{{1
	let len = strlen(a:str)
	let n = ''
	let i = 0
	while i < len
		" Gah, Vim can be lame sometimes. char2nr() on a NUL returns "10".
		" This means the image size might not be right if one of the
		" characters really is a newline.  :(
		let tmp = char2nr(a:str[i])
		let n = n * 256 + (tmp == 10 ? 0 : tmp)
		let i = i + 1
	endwhile

@


1.8
log
@Missing quotes
@
text
@d25 1
a25 1
" $Id: MangleImageTag.vim,v 1.7 2007/01/04 04:29:55 infynity Exp infynity $
d27 3
d175 1
d177 1
d179 1
a179 1
		new
d196 1
@


1.7
log
@Enclose the values of the width/height in quotes by default
@
text
@d25 1
a25 1
" $Id: MangleImageTag.vim,v 1.6 2006/09/22 06:25:14 infynity Exp infynity $
d27 3
d137 1
a137 1
			\ '\0 ' . (case ? 'HEIGHT' : 'height') . '="' . height, '"')
d147 1
a147 1
			\ '\0 ' . (case ? 'WIDTH' : 'width') . '="' . width, '"')
@


1.6
log
@Search for the image file in the current directory and the buffer's directory.
@
text
@d25 1
a25 1
" $Id: MangleImageTag.vim,v 1.5 2006/06/09 07:56:08 infynity Exp infynity $
d27 3
d134 1
a134 1
			\ '\0 ' . (case ? 'HEIGHT' : 'height') . '=' . height, '')
d144 1
a144 1
			\ '\0 ' . (case ? 'WIDTH' : 'width') . '=' . width, '')
@


1.5
log
@Was resetting 'autoindent' globally, switch it to locally.
@
text
@d25 1
a25 1
" $Id: MangleImageTag.vim,v 1.4 2006/06/08 04:16:17 infynity Exp infynity $
d27 3
d105 12
@


1.4
log
@Temporarily reset 'autoindent' (required for Vim7)
@
text
@d25 1
a25 1
" $Id: MangleImageTag.vim,v 1.3 2005/05/19 18:31:31 infynity Exp infynity $
d27 3
d132 1
a132 1
	let &autoindent=0
d136 1
a136 1
	let &autoindent=saveautoindent
@


1.3
log
@SizeGif was returning width as height and vice-versa.
@
text
@d25 1
a25 1
" $Id: MangleImageTag.vim,v 1.2 2004/03/22 10:04:24 infynity Exp infynity $
d27 3
d127 4
d132 2
@


1.2
log
@Update the right tag if more than one IMG tag appears on the line.
@
text
@d25 1
a25 1
" $Id: MangleImageTag.vim,v 1.1 2004/03/22 05:58:34 infynity Exp infynity $
d27 3
d184 2
a185 2
	let height=@@a[1] . @@a[0]
	let width=@@b[1] . @@b[0]
@


1.1
log
@Initial revision
@
text
@d3 3
d10 13
a22 2
" Requirements:
"       VIM 6 or later
d24 10
a33 18
" This program is free software; you can redistribute it and/or modify
" it under the terms of the GNU General Public License as published by
" the Free Software Foundation; either version 2 of the License, or
" (at your option) any later version.
"
" This program is distributed in the hope that it will be useful,
" but WITHOUT ANY WARRANTY; without even the implied warranty of
" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
" GNU General Public License for more details.
"
" You should have received a copy of the GNU General Public License
" along with this program; if not, write to the Free Software
" Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
"
" ------------------------------------------------------------------------- {{{
" $Id$
" $Log$
" ------------------------------------------------------------------------- }}}
d35 1
a35 1
function! MangleImageTag()
d41 11
a51 2
	if line =~? '<img'
		while line !~? '<img\_[^>]*>'
d55 6
d62 9
d72 1
a72 1
		echomsg "Line doesn't contain an image tag."
d78 3
a80 3
	if line =~? "src=\\(\".\\{-}\"\\|'.\\{-}\'\\)"
		let src = substitute(line, ".\\{-}src=\\([\"']\\)\\(.\\{-}\\)\\1.*", '\2', '')
		if line =~# 'src'
d100 2
a101 2
	if line =~? "height=\\(\"\\d\\+\"\\|'\\d\\+\'\\|\\d\\+\\)"
		let line = substitute(line,
d105 1
a105 1
		let line = substitute(line,
d110 2
a111 2
	if line =~? "width=\\(\"\\d\\+\"\\|'\\d\\+\'\\|\\d\\+\\)"
		let line = substitute(line,
d115 1
a115 1
		let line = substitute(line,
d117 1
a117 1
			\ '\0 ' . (case ? 'HEIGHT' : 'height') . '=' . width, '')
d120 1
d124 1
a124 1
function! s:ImageSize(image)
d166 1
a166 1
function! s:SizeGif()
d194 1
a194 1
function! s:SizeJpg()
d222 1
a222 1
function! s:SizePng()
d250 1
a250 1
function! s:Vec(str)
d267 1
a267 1
" vim600:fdm=marker:fdc=2:
@
